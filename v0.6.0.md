# Unify v0.6.0 Implementation Plan

## Overview

This document outlines the implementation plan to upgrade Unify from v0.5.1 to v0.6.0, bringing it into full compliance with the updated app-spec.md. The new version introduces a complete overhaul of the file processing system, new CLI options, and a new Cascading Imports system that replaces SSI-style includes as the primary composition mechanism.

## Current State Analysis

### What's Already Implemented (v0.5.1)
- Basic CLI interface with commands (build, serve, watch, init)
- SSI-style includes (`<!--#include -->`)
- Basic markdown processing with frontmatter
- Asset copying and tracking
- Development server with live reload
- Pretty URLs support (basic)
- Layout discovery system (basic)
- Dependency tracking
- Build caching

### Missing Features (Required for v0.6.0)
- **Cascading Imports System**: `data-import`, `<slot>`, `data-target`
- **New CLI Options**: `--copy`, `--ignore*`, `--render`, `--default-layout`, `--dry-run`, `--auto-ignore`, `--log-level`
- **File Processing Semantics**: Three-tier precedence system
- **Head Merge Algorithm**: Sophisticated head content merging
- **Enhanced File Classification**: New algorithm for render vs copy decisions
- **Enhanced Markdown**: Head synthesis from frontmatter
- **Auto-ignore System**: Automatic ignoring of layouts/includes

## Implementation Plan

### Phase 1: CLI Interface Enhancement

#### 1.1 Update args-parser.js
**Goal**: Add support for all new CLI options specified in app-spec.md

**Current State**: 
- Basic options like `--source`, `--output`, `--port`, `--clean`, `--pretty-urls`, `--minify`
- Missing most new options from spec

**Changes Needed**:
- Add `--copy <glob>` (repeatable)
- Add `--ignore <glob>` (repeatable) 
- Add `--ignore-render <glob>` (repeatable)
- Add `--ignore-copy <glob>` (repeatable)
- Add `--render <glob>` (repeatable)
- Add `--default-layout <value>` (repeatable, supports both filename and glob=filename patterns)
- Add `--dry-run` (boolean)
- Add `--auto-ignore <boolean>` (default: true)
- Add `--fail-level <level>` (replaces `--fail-on`)
- Add `--log-level <level>` (default: info)
- Update help text to match app-spec

**Technical Approach**:
```javascript
// New args structure
const args = {
  // ... existing ...
  copy: [], // array of glob patterns
  ignore: [], // array of glob patterns
  ignoreRender: [], // array of glob patterns
  ignoreCopy: [], // array of glob patterns
  render: [], // array of glob patterns
  defaultLayout: [], // array of layout rules
  dryRun: false,
  autoIgnore: true,
  failLevel: null, // 'warning' | 'error' | null
  logLevel: 'info' // 'error' | 'warn' | 'info' | 'debug'
};
```

#### 1.2 Update CLI Help and Error Messages
**Goal**: Update help text and error messages to match app-spec exactly

**Changes Needed**:
- Update `showHelp()` function with new options
- Add examples from app-spec
- Update error messages for new validation rules

### Phase 2: File Classification System

#### 2.1 Create new file-classifier.js
**Goal**: Implement the three-tier precedence system for file classification

**Current State**: 
- Basic file type detection exists
- No sophisticated classification system

**New System Architecture**:
```javascript
// Classification result
const FileClassification = {
  EMIT: 'emit',     // Render and output as page
  COPY: 'copy',     // Copy as-is
  SKIP: 'skip',     // Ignore completely
  IGNORED: 'ignored' // Explicitly ignored
};

// Three-tier precedence
const PrecedenceTier = {
  EXPLICIT_OVERRIDES: 1, // --render, --auto-ignore=false
  IGNORE_RULES: 2,       // --ignore*, .gitignore
  DEFAULT_BEHAVIOR: 3    // renderables -> EMIT, assets -> COPY
};
```

**Key Functions to Implement**:
- `classifyFile(filePath, options)` - Main classification function
- `isRenderable(filePath)` - Check if file can be rendered
- `matchesGlobPatterns(filePath, patterns)` - Glob matching
- `isAutoIgnored(filePath, options)` - Check auto-ignore rules
- `generateDryRunReport(classifications)` - Generate dry-run output

#### 2.2 Glob Pattern Support
**Goal**: Implement ripgrep/gitignore-style glob patterns with proper precedence

**Technical Approach**:
- Use minimatch or similar library for glob patterns
- Implement "last pattern wins" logic
- Support negation patterns with `!`
- Cross-platform path handling (POSIX internally)

### Phase 3: Cascading Imports System

#### 3.1 Create cascading-imports-processor.js
**Goal**: Implement the new `data-import`, `<slot>`, `data-target` system

**Current State**:
- SSI-style includes work
- Basic DOM templating exists
- No cascading imports system

**New Architecture**:
```javascript
// Import resolution
class ImportResolver {
  resolveImport(importPath, currentFile, sourceRoot) {
    // Full path vs short name resolution
    // Search in current dir, parent dirs, then _includes
  }
}

// Slot injection system
class SlotProcessor {
  processSlots(fragmentHtml, pageContent) {
    // Match data-target to slot names
    // Replace slots with provided content
    // Handle fallback content
  }
}

// Composition engine
class CompositionEngine {
  composeFragments(pageHtml, sourceRoot) {
    // Process data-import attributes
    // Apply slot injection
    // Handle nested imports
    // Circular dependency detection
  }
}
```

**Key Features to Implement**:
- Fragment path resolution (full paths and short names)
- Slot matching and content injection
- Circular dependency detection
- Support for markdown imports
- Automatic layout discovery fallback

#### 3.2 Update unified-html-processor.js
**Goal**: Integrate Cascading Imports into the main processing pipeline

**Changes Needed**:
- Add cascading imports as primary processing method
- Keep SSI includes as fallback/legacy support
- Ensure proper processing order: root import → fragments → page
- Integrate with head merging system

### Phase 4: Head Merge Algorithm

#### 4.1 Create head-merge-processor.js
**Goal**: Implement sophisticated head content merging

**Current State**:
- Basic head merging exists
- No sophisticated deduplication

**New Algorithm**:
```javascript
class HeadMerger {
  mergeHeadContent(layoutHead, fragmentHeads, pageHead) {
    // Processing order: layout → fragments → page
    // Deduplication by element type:
    // - <title>: last wins
    // - <meta>: dedupe by name/property, last wins
    // - <link>: dedupe by (rel, href), first wins unless data-allow-duplicate
    // - <script>: dedupe by src, first wins unless data-allow-duplicate
    // - <style>: dedupe by href, first wins unless data-allow-duplicate
  }
}
```

**Features to Implement**:
- Deterministic deduplication rules
- Support for `data-allow-duplicate` attribute
- CSS layer hints with `data-layer`
- Script execution order preservation
- Safety and sanitization

#### 4.2 Enhanced Markdown Head Synthesis
**Goal**: Convert markdown frontmatter to `<head>` elements

**Current State**:
- Basic frontmatter processing
- No head synthesis

**New Features**:
```yaml
# Frontmatter schema
title: string
description: string
head:
  meta: [{name: ..., content: ...}, ...]
  link: [{rel: ..., href: ...}, ...]
  script: [{src: ...} or {type: "application/ld+json", json: {...}}]
  style: [{inline: "..."} or {href: "..."}]
```

**Synthesis Rules**:
- `title` → `<title>`
- `description` → `<meta name="description">`
- `head.meta` items → `<meta>` elements
- `head.link` items → `<link>` elements
- `head.script` items → `<script>` elements
- `head.style` items → `<style>` or `<link rel="stylesheet">`

### Phase 5: Enhanced File Processing

#### 5.1 Update file-processor.js
**Goal**: Integrate new classification system and processing pipeline

**Changes Needed**:
- Use new file classifier for all processing decisions
- Implement dry-run mode
- Support new fail-level logic
- Integrate with new auto-ignore system
- Update build reporting to match spec

#### 5.2 Auto-ignore System
**Goal**: Automatically ignore layout and include files

**Implementation**:
- Track files referenced as layouts (via `--default-layout`, frontmatter, discovery)
- Track files referenced as includes/imports
- Automatically exclude from EMIT and COPY unless explicitly overridden
- Respect `--auto-ignore=false` to disable

### Phase 6: Enhanced Link Normalization

#### 6.1 Update link-transformer.js
**Goal**: Implement comprehensive link normalization for pretty URLs

**Current State**:
- Basic link transformation exists
- Limited to simple cases

**Enhanced Features**:
- Transform HTML page links: `./about.html` → `/about/`
- Preserve query parameters and fragments
- Handle index.html special case: `../index.html` → `/`
- Skip external URLs, email links, protocol links
- Skip non-HTML files and data URLs
- Cross-platform path handling

### Phase 7: Logging and Developer Experience

#### 7.1 Update logger.js
**Goal**: Implement new logging levels and improve developer experience

**Current State**:
- Basic logging with limited levels

**New Features**:
- Support levels: error, warn, info, debug
- Structured dry-run output
- Performance warnings for broad patterns
- Collision detection warnings
- Clear classification reasoning in debug mode

#### 7.2 Enhanced Error Messages
**Goal**: Improve error messages with actionable suggestions

**Features**:
- File classification conflicts
- Circular dependency detection
- Missing slot targets
- Invalid glob patterns
- Layout discovery failures

### Phase 8: Testing Strategy

#### 8.1 Unit Tests
**Goal**: Test each new component in isolation

**New Test Files Needed**:
- `test/unit/file-classifier.test.js`
- `test/unit/cascading-imports.test.js`
- `test/unit/head-merger.test.js`
- `test/unit/cli-options-v6.test.js`
- `test/unit/glob-patterns.test.js`

#### 8.2 Integration Tests
**Goal**: Test complete workflows and CLI scenarios

**New Test Scenarios**:
- Full cascading imports workflow
- Complex file classification scenarios
- Dry-run mode testing
- Head merging with multiple fragments
- Auto-ignore system testing
- Link normalization edge cases

#### 8.3 Performance Tests
**Goal**: Ensure new features don't degrade performance

**Test Scenarios**:
- Large projects (1000+ pages)
- Complex dependency chains
- Broad glob patterns
- Memory usage with new processing

### Phase 9: Documentation and Examples

#### 9.1 Update Examples
**Goal**: Create examples showcasing new features

**Examples Needed**:
- Basic cascading imports
- Complex slot injection
- Head merging scenarios
- File classification patterns
- Glob pattern usage

#### 9.2 Update Documentation
**Goal**: Update all documentation to reflect new features

**Files to Update**:
- README.md
- CLI help text
- Error messages
- Code comments

## Implementation Order

### Week 1: Foundation
1. Update CLI interface (args-parser.js)
2. Create file classifier
3. Add glob pattern support
4. Update logging system

### Week 2: Core Features
1. Implement cascading imports system
2. Create head merge algorithm
3. Update unified HTML processor
4. Enhance markdown processing

### Week 3: Integration
1. Update main file processor
2. Implement auto-ignore system
3. Enhance link normalization
4. Update error handling

### Week 4: Testing and Polish
1. Write comprehensive tests
2. Fix bugs and edge cases
3. Update documentation
4. Performance optimization

## Success Criteria

### Functional Requirements ✅
- [ ] All CLI options from app-spec implemented
- [ ] Cascading imports system working
- [ ] File classification with three-tier precedence
- [ ] Head merge algorithm implemented
- [ ] Auto-ignore system working
- [ ] Enhanced link normalization
- [ ] Dry-run mode functional

### Compatibility Requirements ✅
- [ ] All existing tests pass
- [ ] SSI includes still work (legacy support)
- [ ] Existing projects build without changes
- [ ] Performance not degraded

### Quality Requirements ✅
- [ ] 100% test coverage for new features
- [ ] Clear error messages
- [ ] Comprehensive documentation
- [ ] Cross-platform compatibility

## Risk Mitigation

### Breaking Changes
- Keep SSI includes as fallback for compatibility
- Provide clear migration guide
- Add deprecation warnings where appropriate

### Performance Risks
- Optimize glob pattern matching
- Cache classification results
- Profile memory usage
- Benchmark against v0.5.1

### Complexity Risks
- Break down into small, testable components
- Use TypeScript-style JSDoc for better APIs
- Extensive unit testing
- Clear separation of concerns

## Detailed Technical Solutions & Test Examples

### Phase 1 Technical Solutions

#### 1.1 Enhanced args-parser.js Implementation

**Example Implementation:**
```javascript
// Enhanced args structure with arrays for repeatable options
export function parseArgs(argv) {
  const args = {
    // ... existing ...
    copy: [],
    ignore: [],
    ignoreRender: [],
    ignoreCopy: [],
    render: [],
    defaultLayout: [],
    dryRun: false,
    autoIgnore: true,
    failLevel: null,
    logLevel: 'info'
  };

  // Handle repeatable options
  if (arg === '--copy' && nextArg && !nextArg.startsWith('-')) {
    args.copy.push(nextArg);
    i += 2;
    continue;
  }
  
  // Handle default-layout with glob support
  if (arg === '--default-layout' && nextArg && !nextArg.startsWith('-')) {
    if (nextArg.includes('=')) {
      const [pattern, layout] = nextArg.split('=');
      args.defaultLayout.push({ pattern, layout });
    } else {
      args.defaultLayout.push({ pattern: '*', layout: nextArg });
    }
    i += 2;
    continue;
  }
}
```

**Test Example:**
```javascript
// test/unit/cli-options-v6.test.js
import { test, expect } from 'bun:test';
import { parseArgs } from '../../src/cli/args-parser.js';

test('parseArgs should handle repeatable copy options', () => {
  const args = parseArgs(['build', '--copy', 'assets/**', '--copy', 'docs/**']);
  expect(args.copy).toEqual(['assets/**', 'docs/**']);
});

test('parseArgs should handle default-layout with glob patterns', () => {
  const args = parseArgs(['build', '--default-layout', 'blog/**=_post.html']);
  expect(args.defaultLayout).toEqual([
    { pattern: 'blog/**', layout: '_post.html' }
  ]);
});

test('parseArgs should handle log-level validation', () => {
  const args = parseArgs(['build', '--log-level', 'debug']);
  expect(args.logLevel).toBe('debug');
  
  expect(() => parseArgs(['build', '--log-level', 'invalid']))
    .toThrow('Invalid log level: invalid');
});
```

### Phase 2 Technical Solutions

#### 2.1 File Classification System Implementation

**Recommended Technical Solution:**
```javascript
// src/core/file-classifier.js
import { minimatch } from 'minimatch';
import path from 'path';
import fs from 'fs/promises';

export class FileClassifier {
  constructor(options = {}) {
    this.options = {
      autoIgnore: true,
      copy: [],
      ignore: [],
      ignoreRender: [],
      ignoreCopy: [],
      render: [],
      sourceRoot: 'src',
      ...options
    };
  }

  async classifyFile(filePath) {
    const classification = {
      action: null,
      reason: '',
      tier: null
    };

    // Convert to POSIX for cross-platform compatibility
    const posixPath = filePath.replace(/\\/g, '/');
    
    // Tier 1: Explicit Overrides
    if (this.matchesPattern(posixPath, this.options.render)) {
      classification.action = 'EMIT';
      classification.reason = `--render pattern match`;
      classification.tier = 1;
      return classification;
    }

    // Tier 2: Ignore Rules
    if (this.matchesPattern(posixPath, this.options.ignore)) {
      classification.action = 'IGNORED';
      classification.reason = `--ignore pattern match`;
      classification.tier = 2;
      return classification;
    }

    if (this.matchesPattern(posixPath, this.options.ignoreRender) && this.isRenderable(filePath)) {
      classification.action = 'IGNORED';
      classification.reason = `--ignore-render pattern match`;
      classification.tier = 2;
      return classification;
    }

    // Auto-ignore layout and include files
    if (this.options.autoIgnore && await this.isAutoIgnoredFile(filePath)) {
      classification.action = 'IGNORED';
      classification.reason = `auto-ignore (layout/include file)`;
      classification.tier = 2;
      return classification;
    }

    // Tier 3: Default Behavior
    if (this.isRenderable(filePath)) {
      classification.action = 'EMIT';
      classification.reason = `renderable file (.html, .md)`;
      classification.tier = 3;
    } else if (this.matchesPattern(posixPath, [...this.options.copy, 'assets/**'])) {
      classification.action = 'COPY';
      classification.reason = `asset or copy pattern match`;
      classification.tier = 3;
    } else {
      classification.action = 'SKIP';
      classification.reason = `non-renderable, no copy rule`;
      classification.tier = 3;
    }

    return classification;
  }

  isRenderable(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    return ['.html', '.htm', '.md'].includes(ext);
  }

  matchesPattern(filePath, patterns) {
    if (!patterns || patterns.length === 0) return false;
    
    // Last pattern wins (ripgrep-style)
    for (let i = patterns.length - 1; i >= 0; i--) {
      const pattern = patterns[i];
      if (pattern.startsWith('!')) {
        // Negation pattern
        if (minimatch(filePath, pattern.slice(1))) {
          return false;
        }
      } else {
        if (minimatch(filePath, pattern)) {
          return true;
        }
      }
    }
    return false;
  }

  async isAutoIgnoredFile(filePath) {
    // Check if file starts with underscore
    const basename = path.basename(filePath);
    if (basename.startsWith('_')) return true;
    
    // Check if in underscore directory
    const parts = filePath.split(path.sep);
    return parts.some(part => part.startsWith('_'));
  }
}
```

**Test Example:**
```javascript
// test/unit/file-classifier.test.js
import { test, expect } from 'bun:test';
import { FileClassifier } from '../../src/core/file-classifier.js';
import { createTempDir, writeTempFile } from '../test-utils.js';

test('FileClassifier should implement three-tier precedence', async () => {
  const tempDir = await createTempDir();
  const classifier = new FileClassifier({
    sourceRoot: tempDir,
    ignore: ['blog/**'],
    render: ['blog/featured/**'],
    ignoreRender: ['blog/featured/draft.md']
  });

  // Tier 1: --render wins over --ignore
  const featured = await classifier.classifyFile('blog/featured/post.md');
  expect(featured.action).toBe('EMIT');
  expect(featured.tier).toBe(1);

  // Tier 2: --ignore-render wins
  const draft = await classifier.classifyFile('blog/featured/draft.md');
  expect(draft.action).toBe('IGNORED');
  expect(draft.tier).toBe(2);

  // Tier 2: --ignore wins
  const regular = await classifier.classifyFile('blog/other/post.md');
  expect(regular.action).toBe('IGNORED');
  expect(regular.tier).toBe(2);
});

test('FileClassifier should handle glob patterns with negation', async () => {
  const classifier = new FileClassifier({
    copy: ['assets/**', '!assets/private/**']
  });

  const publicAsset = await classifier.classifyFile('assets/images/logo.png');
  expect(publicAsset.action).toBe('COPY');

  const privateAsset = await classifier.classifyFile('assets/private/secret.png');
  expect(privateAsset.action).toBe('SKIP');
});
```

### Phase 3 Technical Solutions

#### 3.1 Cascading Imports System Implementation

**Recommended Technical Solution:**
```javascript
// src/core/cascading-imports-processor.js
import { HTMLRewriter } from 'bun';
import fs from 'fs/promises';
import path from 'path';

export class CascadingImportsProcessor {
  constructor(sourceRoot, options = {}) {
    this.sourceRoot = sourceRoot;
    this.options = options;
    this.importStack = new Set(); // Circular dependency detection
  }

  async processImports(html, currentFile) {
    let processedHtml = html;
    const imports = this.extractImports(html);
    
    for (const importInfo of imports) {
      const fragmentContent = await this.resolveFragment(
        importInfo.src, 
        currentFile
      );
      
      const composedContent = this.composeFragments(
        fragmentContent,
        importInfo.slotContent
      );
      
      processedHtml = this.replaceImport(
        processedHtml, 
        importInfo.element, 
        composedContent
      );
    }
    
    return processedHtml;
  }

  extractImports(html) {
    const imports = [];
    const rewriter = new HTMLRewriter();
    
    rewriter.on('[data-import]', {
      element(element) {
        const src = element.getAttribute('data-import');
        if (src) {
          imports.push({
            src,
            element: element.toString(),
            slotContent: this.extractSlotContent(element)
          });
        }
      }
    });
    
    return imports;
  }

  async resolveFragment(importPath, currentFile) {
    // Circular dependency check
    if (this.importStack.has(importPath)) {
      throw new Error(`Circular import detected: ${Array.from(this.importStack).join(' → ')} → ${importPath}`);
    }
    
    this.importStack.add(importPath);
    
    try {
      const resolvedPath = await this.resolveImportPath(importPath, currentFile);
      const content = await fs.readFile(resolvedPath, 'utf-8');
      
      // Process nested imports recursively
      return await this.processImports(content, resolvedPath);
    } finally {
      this.importStack.delete(importPath);
    }
  }

  async resolveImportPath(importPath, currentFile) {
    const candidates = [];
    
    if (importPath.startsWith('/')) {
      // Absolute from source root
      candidates.push(path.resolve(this.sourceRoot, importPath.slice(1)));
    } else {
      // Relative to current file
      candidates.push(path.resolve(path.dirname(currentFile), importPath));
    }
    
    // Short name resolution
    if (!importPath.includes('/') && !importPath.includes('.')) {
      const shortNameCandidates = this.generateShortNameCandidates(importPath, currentFile);
      candidates.push(...shortNameCandidates);
    }
    
    for (const candidate of candidates) {
      try {
        await fs.access(candidate);
        return candidate;
      } catch {}
    }
    
    throw new Error(`Fragment not found: ${importPath}`);
  }

  generateShortNameCandidates(shortName, currentFile) {
    const candidates = [];
    const extensions = ['.html', '.htm'];
    const patterns = [
      `${shortName}`,
      `_${shortName}`,
      `${shortName}.layout`,
      `_${shortName}.layout`
    ];
    
    // Search from current directory up to source root
    let currentDir = path.dirname(currentFile);
    while (currentDir !== path.dirname(currentDir)) {
      for (const pattern of patterns) {
        for (const ext of extensions) {
          candidates.push(path.join(currentDir, pattern + ext));
        }
      }
      currentDir = path.dirname(currentDir);
      if (currentDir === this.sourceRoot) break;
    }
    
    // Search in _includes
    for (const pattern of patterns) {
      for (const ext of extensions) {
        candidates.push(path.join(this.sourceRoot, '_includes', pattern + ext));
      }
    }
    
    return candidates;
  }

  composeFragments(fragmentHtml, slotContent) {
    let composed = fragmentHtml;
    
    // Process named slots
    for (const [slotName, content] of Object.entries(slotContent.named || {})) {
      const slotPattern = new RegExp(
        `<slot\\s+name=["']${slotName}["'][^>]*>([\\s\\S]*?)</slot>`, 
        'gi'
      );
      composed = composed.replace(slotPattern, content);
    }
    
    // Process default slot
    if (slotContent.default) {
      const defaultSlotPattern = /<slot(?:\s+(?!name=)[^>]*)?>([\\s\\S]*?)<\/slot>/gi;
      composed = composed.replace(defaultSlotPattern, slotContent.default);
    }
    
    return composed;
  }
}
```

**Test Example:**
```javascript
// test/unit/cascading-imports.test.js
import { test, expect } from 'bun:test';
import { CascadingImportsProcessor } from '../../src/core/cascading-imports-processor.js';
import { createTempDir, writeTempFile } from '../test-utils.js';

test('CascadingImportsProcessor should process basic imports', async () => {
  const tempDir = await createTempDir();
  
  // Create layout
  await writeTempFile(tempDir, '_layout.html', `
    <html>
      <head><title>Site</title></head>
      <body>
        <header><slot name="header">Default Header</slot></header>
        <main><slot>Default Content</slot></main>
      </body>
    </html>
  `);
  
  // Create page
  const pageHtml = `
    <div data-import="_layout.html">
      <h1>Page Content</h1>
      <template data-target="header">
        <h1>Custom Header</h1>
      </template>
    </div>
  `;
  
  const processor = new CascadingImportsProcessor(tempDir);
  const result = await processor.processImports(pageHtml, path.join(tempDir, 'page.html'));
  
  expect(result).toContain('<h1>Custom Header</h1>');
  expect(result).toContain('<h1>Page Content</h1>');
  expect(result).not.toContain('data-import');
});

test('CascadingImportsProcessor should detect circular dependencies', async () => {
  const tempDir = await createTempDir();
  
  await writeTempFile(tempDir, 'a.html', '<div data-import="b.html">A</div>');
  await writeTempFile(tempDir, 'b.html', '<div data-import="a.html">B</div>');
  
  const processor = new CascadingImportsProcessor(tempDir);
  
  await expect(
    processor.processImports('<div data-import="a.html">Test</div>', path.join(tempDir, 'test.html'))
  ).rejects.toThrow('Circular import detected');
});
```

### Phase 4 Technical Solutions

#### 4.1 Head Merge Algorithm Implementation

**Recommended Technical Solution:**
```javascript
// src/core/head-merge-processor.js
export class HeadMergeProcessor {
  constructor() {
    this.processedElements = new Map();
  }

  mergeHeadContent(fragments) {
    // fragments = [{ source: 'layout', headHtml: '...' }, { source: 'page', headHtml: '...' }]
    const mergedElements = [];
    
    // Process in order: layout → fragments → page
    for (const fragment of fragments) {
      const elements = this.parseHeadElements(fragment.headHtml);
      for (const element of elements) {
        this.processElement(element, mergedElements);
      }
    }
    
    return this.renderMergedHead(mergedElements);
  }

  processElement(element, mergedElements) {
    const key = this.getDeduplicationKey(element);
    
    if (!key) {
      // No deduplication for unknown elements
      mergedElements.push(element);
      return;
    }
    
    const existingIndex = mergedElements.findIndex(existing => 
      this.getDeduplicationKey(existing) === key
    );
    
    if (existingIndex === -1) {
      mergedElements.push(element);
    } else {
      // Apply deduplication rules
      const replacement = this.applyDeduplicationRule(
        mergedElements[existingIndex], 
        element
      );
      if (replacement) {
        mergedElements[existingIndex] = replacement;
      }
    }
  }

  getDeduplicationKey(element) {
    const { tagName, attributes } = element;
    
    switch (tagName.toLowerCase()) {
      case 'title':
        return 'title';
      case 'meta':
        return `meta:${attributes.name || attributes.property || attributes['http-equiv']}`;
      case 'link':
        return `link:${attributes.rel}:${attributes.href}`;
      case 'script':
        if (attributes.src) {
          return `script:src:${attributes.src}`;
        }
        // Inline scripts not deduplicated
        return null;
      case 'style':
        if (attributes.href) {
          return `style:href:${attributes.href}`;
        }
        // Inline styles not deduplicated
        return null;
      default:
        return null;
    }
  }

  applyDeduplicationRule(existing, incoming) {
    const { tagName } = incoming;
    
    switch (tagName.toLowerCase()) {
      case 'title':
        // Last wins
        return incoming;
      case 'meta':
        // Last wins (page beats layout)
        return incoming;
      case 'link':
      case 'script':
      case 'style':
        // First wins unless data-allow-duplicate
        if (incoming.attributes['data-allow-duplicate'] !== undefined) {
          return null; // Keep both
        }
        return existing; // Keep existing
      default:
        return incoming;
    }
  }
}
```

**Test Example:**
```javascript
// test/unit/head-merger.test.js
import { test, expect } from 'bun:test';
import { HeadMergeProcessor } from '../../src/core/head-merge-processor.js';

test('HeadMergeProcessor should merge titles with last-wins', () => {
  const processor = new HeadMergeProcessor();
  
  const fragments = [
    { source: 'layout', headHtml: '<title>Site</title>' },
    { source: 'page', headHtml: '<title>Page Title</title>' }
  ];
  
  const result = processor.mergeHeadContent(fragments);
  expect(result).toContain('<title>Page Title</title>');
  expect(result).not.toContain('<title>Site</title>');
});

test('HeadMergeProcessor should deduplicate meta tags by name', () => {
  const processor = new HeadMergeProcessor();
  
  const fragments = [
    { 
      source: 'layout', 
      headHtml: '<meta name="description" content="Site description">' 
    },
    { 
      source: 'page', 
      headHtml: '<meta name="description" content="Page description">' 
    }
  ];
  
  const result = processor.mergeHeadContent(fragments);
  expect(result).toContain('Page description');
  expect(result).not.toContain('Site description');
});

test('HeadMergeProcessor should preserve scripts with data-allow-duplicate', () => {
  const processor = new HeadMergeProcessor();
  
  const fragments = [
    { 
      source: 'layout', 
      headHtml: '<script src="common.js"></script>' 
    },
    { 
      source: 'page', 
      headHtml: '<script src="common.js" data-allow-duplicate></script>' 
    }
  ];
  
  const result = processor.mergeHeadContent(fragments);
  expect((result.match(/src="common\.js"/g) || []).length).toBe(2);
});
```

### Phase 5 Technical Solutions

#### 5.1 Enhanced Markdown Head Synthesis

**Recommended Technical Solution:**
```javascript
// src/core/markdown-head-synthesis.js
export function synthesizeHeadFromFrontmatter(frontmatter) {
  const headElements = [];
  
  // Basic meta tags
  if (frontmatter.title) {
    headElements.push({
      tagName: 'title',
      content: frontmatter.title,
      attributes: {}
    });
  }
  
  if (frontmatter.description) {
    headElements.push({
      tagName: 'meta',
      attributes: {
        name: 'description',
        content: frontmatter.description
      }
    });
  }
  
  // Process head object
  if (frontmatter.head) {
    const { meta, link, script, style } = frontmatter.head;
    
    // Meta tags
    if (meta && Array.isArray(meta)) {
      for (const metaItem of meta) {
        headElements.push({
          tagName: 'meta',
          attributes: metaItem
        });
      }
    }
    
    // Link tags
    if (link && Array.isArray(link)) {
      for (const linkItem of link) {
        headElements.push({
          tagName: 'link',
          attributes: linkItem
        });
      }
    }
    
    // Script tags
    if (script && Array.isArray(script)) {
      for (const scriptItem of script) {
        if (scriptItem.json) {
          headElements.push({
            tagName: 'script',
            attributes: { type: 'application/ld+json' },
            content: JSON.stringify(scriptItem.json)
          });
        } else {
          headElements.push({
            tagName: 'script',
            attributes: scriptItem
          });
        }
      }
    }
    
    // Style tags
    if (style && Array.isArray(style)) {
      for (const styleItem of style) {
        if (styleItem.inline) {
          headElements.push({
            tagName: 'style',
            content: styleItem.inline,
            attributes: {}
          });
        } else if (styleItem.href) {
          headElements.push({
            tagName: 'link',
            attributes: {
              rel: 'stylesheet',
              ...styleItem
            }
          });
        }
      }
    }
  }
  
  return headElements;
}
```

**Test Example:**
```javascript
// test/unit/markdown-head-synthesis.test.js
import { test, expect } from 'bun:test';
import { synthesizeHeadFromFrontmatter } from '../../src/core/markdown-head-synthesis.js';

test('synthesizeHeadFromFrontmatter should create title and description', () => {
  const frontmatter = {
    title: 'Test Page',
    description: 'A test page'
  };
  
  const elements = synthesizeHeadFromFrontmatter(frontmatter);
  
  const title = elements.find(el => el.tagName === 'title');
  expect(title.content).toBe('Test Page');
  
  const meta = elements.find(el => 
    el.tagName === 'meta' && el.attributes.name === 'description'
  );
  expect(meta.attributes.content).toBe('A test page');
});

test('synthesizeHeadFromFrontmatter should process JSON-LD scripts', () => {
  const frontmatter = {
    head: {
      script: [
        {
          json: {
            "@context": "https://schema.org",
            "@type": "Article",
            "headline": "Test"
          }
        }
      ]
    }
  };
  
  const elements = synthesizeHeadFromFrontmatter(frontmatter);
  const script = elements.find(el => el.tagName === 'script');
  
  expect(script.attributes.type).toBe('application/ld+json');
  expect(script.content).toContain('"@type":"Article"');
});
```

### Phase 8 Technical Solutions

#### 8.1 Comprehensive Integration Tests

**Recommended Test Structure:**
```javascript
// test/integration/cascading-imports-complete.test.js
import { test, expect } from 'bun:test';
import { build } from '../../src/core/file-processor.js';
import { createTempDir, writeTempFile } from '../test-utils.js';

test('complete cascading imports workflow with head merging', async () => {
  const tempDir = await createTempDir();
  
  // Create base layout
  await writeTempFile(tempDir, '_layout.html', `
    <!DOCTYPE html>
    <html>
      <head>
        <title>Site</title>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="/css/base.css">
      </head>
      <body>
        <header><slot name="header">Default Header</slot></header>
        <main><slot>Default Content</slot></main>
        <footer><slot name="footer">© Site</slot></footer>
      </body>
    </html>
  `);
  
  // Create page with markdown content
  await writeTempFile(tempDir, 'blog/post.md', `---
title: "Blog Post"
description: "A test blog post"
head:
  meta:
    - property: "og:title"
      content: "Blog Post"
  link:
    - rel: "canonical"
      href: "https://example.com/blog/post"
---

# Blog Post

This is a test blog post with **markdown** content.
  `);
  
  // Create blog layout
  await writeTempFile(tempDir, 'blog/_layout.html', `
    <div data-import="../_layout.html">
      <div data-target="header">
        <h1>Blog Header</h1>
      </div>
      
      <article>
        <slot>Blog content here</slot>
      </article>
    </div>
  `);
  
  const result = await build({
    source: tempDir,
    output: path.join(tempDir, 'dist'),
    pretty: true
  });
  
  expect(result.processed).toBeGreaterThan(0);
  
  // Check output file
  const outputPath = path.join(tempDir, 'dist', 'blog', 'post', 'index.html');
  const output = await fs.readFile(outputPath, 'utf-8');
  
  // Should have merged head content
  expect(output).toContain('<title>Blog Post</title>'); // Page wins
  expect(output).toContain('name="viewport"'); // From layout
  expect(output).toContain('property="og:title"'); // From page
  expect(output).toContain('rel="canonical"'); // From page
  
  // Should have composed content
  expect(output).toContain('<h1>Blog Header</h1>');
  expect(output).toContain('<h1 id="blog-post">Blog Post</h1>'); // Processed markdown
  expect(output).toContain('<strong>markdown</strong>');
  
  // Should not have template artifacts
  expect(output).not.toContain('data-import');
  expect(output).not.toContain('data-target');
  expect(output).not.toContain('<slot>');
});
```

## Next Steps

1. **Start with Phase 1**: CLI interface enhancement as foundation
2. **Implement incrementally**: Each phase builds on previous
3. **Test continuously**: Write tests alongside implementation
4. **Monitor performance**: Benchmark each phase
5. **Document as we go**: Keep docs current with implementation

This implementation plan provides a structured approach to achieving 100% compliance with the new app-spec while maintaining compatibility and performance.